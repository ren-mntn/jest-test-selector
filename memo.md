# testTreeDataProvider.ts パフォーマンス改善案

## 効果が高いと想定される改善案

1.  **ツリー更新ロジックの最適化:** (最重要)

    - `refresh`: 全体再構築ではなく、変更のあった部分のみ差分更新する仕組みを導入 (最も効果が大きい可能性)
    - イベントハンドラに Debounce 処理を追加し、短時間に連続して発生するイベントをまとめて処理 (UI のちらつきや無駄な処理を大幅削減)

2.  **UI 更新の最適化:**

    - `_onDidChangeTreeData.fire()`: 引数なし（全体更新）ではなく、変更された特定のアイテムを指定して部分的な更新を実現 (VS Code 側の描画負荷を軽減)

3.  **ファイル I/O とパース処理の最適化:**

    - `extractTestCases`: ファイル変更時の完全再抽出を避け、差分更新やキャッシュを導入 (ファイル変更時の応答性向上)
    - `findPackageDirectoryWithJestConfig`: 階層を遡る代わりに `vscode.workspace.findFiles` を使用 (設定ファイル検索の高速化)
    - `findAllTestFilesInDirectory`: 全エントリ読み込みではなく、`vscode.workspace.findFiles` でテストファイルのみ効率的に検索 (ディレクトリ内のテストファイル検索の高速化)

4.  **データ構造と検索の最適化:**

    - `checkFileTestStatus`: テスト結果の保存形式や検索ロジックを見直し、ファイルステータスチェックを高速化 (アイコン更新などの処理速度向上)

5.  **レンダリング最適化:**
    - 表示されていない（折りたたまれている）ノードの詳細データの遅延ロード (初期表示や大規模ツリーでの表示速度向上)
    - ビューポート内に表示されるノードのみを優先的に処理する仕組み (スクロール時のパフォーマンス改善)

## 中程度の効果が期待される改善案

6.  **非同期処理と並列化:**

    - ファイル読み込みやテスト抽出などの重い処理を Promise.all で並列化 (全体的な処理時間の短縮)
    - バックグラウンドでのプリフェッチやプリロード導入 (体感速度の向上)

7.  **キャッシュ戦略の改善:**

    - LRU キャッシュの導入で、よく使われるデータを効率的に保持 (計算結果やファイル内容の再利用効率化)
    - メモ化（計算結果の再利用）による重複計算の回避 (特定の計算処理の高速化)

8.  **メモリ使用量の最適化:**

    - 不要な TestNode オブジェクトの早期解放 (メモリ効率改善、GC 負荷軽減)
    - キャッシュのライフサイクル管理（長時間不使用のキャッシュクリア）(メモリリーク防止)
    - 大きな配列やオブジェクトを処理する際のメモリ効率の良い方法の採用

9.  **データ量の削減:**
    - テストケース情報の必要最小限化（使用しない属性の省略）(データ転送量・メモリ使用量の削減)
    - 大きなデータ構造の分割と必要に応じた取得（遅延ロード）

## 効果が状況に依存する、または限定的な改善案

10. **リソース解放の徹底:**

    - 使用していない EventEmitter やリスナーの適切な破棄 (メモリリーク防止、長期安定性向上)
    - dispose()メソッドの完全実装によるリソースリーク防止 (同上)

11. **コードの簡素化:**

    - ロジックの複雑さを減らし、条件分岐や計算を簡略化 (可読性・保守性向上、間接的にバグや非効率な処理を減らす可能性)
    - 複数の似た処理を統合し、コード重複を削減 (同上)

12. **再帰処理の最適化:**
    - `findNode`などの再帰関数をループに置き換える検討 (スタックオーバーフローのリスク軽減、状況により微細な速度向上)
    - スタックオーバーフローを避けるため、深い再帰を制限または反復処理へ変換 (非常に深いツリー構造での安定性向上)

## 実装済みの改善 (2024-05-XX)

### 1. ツリー更新ロジックの最適化

以下の改善を宣言的・関数型スタイルで実装しました：

1. **debounce 処理の導入**

   - 汎用的な`debounce`高階関数を実装し、頻繁に発生するイベントを一定時間（300ms）ごとにまとめて処理するようにしました
   - エディタ切り替え、テスト結果更新、テキスト変更の各イベントハンドラに適用し、UI のちらつき防止と処理負荷軽減を実現

2. **差分更新の仕組み導入**

   - 前回のノード状態を`Map`データ構造に保存し、変更があった部分のみを更新する仕組みを実装
   - ファイルパス、ノードタイプ、ノード名を組み合わせた一意のキーでノード追跡
   - 不要な全体再構築を回避し、変更のあったノードのみ効率的に更新

3. **再帰処理の最適化**

   - 再帰呼び出しを使用せず、スタックベースの反復処理に置き換え
   - `saveNodeState`メソッドではスタックを使用した非再帰的なツリー走査を実装
   - スタックオーバーフローリスクの軽減と処理効率の向上

4. **不必要なツリー再構築の回避**
   - 同じファイルやディレクトリの場合、テスト結果のみの変更なら部分更新のみ実行
   - キャッシュキー導入による効率的な状態追跡
   - 条件分岐を簡素化し、処理パスを明確化

これらの改善により、特に大規模なテストファイル集合やディープなテスト階層を持つプロジェクトで顕著なパフォーマンス向上が期待できます。

### 2. UI 更新の最適化

以下の改善を関数型・宣言的スタイルで実装しました：

1. **選択的な UI 更新の実装**

   - 変更された特定のノードだけを更新する機能を追加
   - `_onDidChangeTreeData.fire()`に引数として変更されたアイテムを渡すことで、VS Code の部分的な再描画を実現
   - 完全な再描画が必要ない場合のレンダリング負荷を大幅に軽減

2. **TreeItem のキャッシュ機構**

   - `Map`データ構造を使用して生成済みの`TreeItem`をキャッシュする仕組みを導入
   - 一意のノードキーを使ってキャッシュから効率的に`TreeItem`を検索可能に
   - キャッシュを通じて特定のノードを参照し、部分的な更新に利用

3. **変更検知の高度化**

   - ノード間の差分検出を強化し、JSON.stringify を使った深い比較を実装
   - テストケースやファイルの状態変化を精密に検知するロジックを追加
   - 変更量に応じた更新戦略の自動選択（少数の変更は個別更新、多数の場合は全体更新）

4. **コンポジション（合成）パターンの適用**

   - 独立した関数で構成された変更通知メカニズム
   - `notifyNodesChanged`、`findTreeItemByNodeKey`などの特化した関数によるモジュール化
   - 単一責任の原則に基づいた関数設計で、コードの保守性と拡張性を向上

これらの改善により、頻繁なテスト結果の更新や大規模なテストスイートを持つプロジェクトでの UI 応答性が大幅に向上します。特に、テスト実行中の逐次的な結果表示や、多数のネストされたテストグループを持つファイルの編集時に効果を発揮します。

### 3. ファイル I/O とパース処理の最適化

以下の改善を関数型・宣言的プログラミングスタイルで実装しました：

1. **テストケース抽出の効率化**

   - 時間ベースのキャッシュ戦略を導入し、`getTestCasesWithCache` メソッドによるテストケースの効率的な取得を実現
   - 同一ファイルに対する重複抽出を防止し、ファイル変更時のみ再解析を行うように最適化
   - ファイルごとにテストケースを`Map`構造でキャッシュし、高速なルックアップを実現

2. **テストファイル検索の高速化**

   - 従来の`fs.readDirectory`によるディレクトリ全走査から`vscode.workspace.findFiles`を使用した効率的な検索に変更
   - ファイルパターンに基づく並列検索で、大規模プロジェクトでの検索パフォーマンスを大幅に向上
   - 検索結果のキャッシュ導入による重複クエリの削減

3. **Jest 設定ファイル検索の最適化**

   - 再帰的なディレクトリ走査を廃止し、`vscode.workspace.findFiles`を活用した高速な設定ファイル検索を実装
   - `node_modules`などの不要なディレクトリを除外した効率的なファイル検索
   - 関数型プログラミング手法を用いた「最も近い設定ファイル」検索アルゴリズムの実装

4. **並列処理による効率化**

   - 複数のテストファイルの処理を`Promise.all`を使って並列化
   - 純粋関数と高階関数を組み合わせた宣言的な非同期処理
   - マルチコア活用による処理時間の短縮

5. **有効期限付きキャッシュ戦略**

   - 各キャッシュにタイムスタンプとデータを組み合わせた構造を導入
   - 一定時間（デフォルト 1 分）後にキャッシュを自動的に無効化することで、常に最新のデータとのバランスを確保
   - メモリ使用量とパフォーマンスのトレードオフを最適化

これらの改善により、特に以下のシナリオでパフォーマンスが向上します：

- 大規模なモノレポ構造を持つプロジェクト
- 多数のテストファイルを含むディレクトリの処理
- 深いディレクトリ階層を持つプロジェクトの Jest 設定ファイル検索

これらの最適化は関数型アプローチを取り入れることで副作用を限定し、メンテナンス性とテスト容易性も向上させています。

### 4. データ構造と検索の最適化提案

以下の改善を関数型・宣言的プログラミングスタイルで実装することを提案します：

1. **テスト結果インデックスの効率化**

   - `trie`データ構造を活用したファイルパスとテスト名のインデックス構築
   - 前方一致・部分一致の高速検索が可能なインデックス設計
   - ハッシュマップベースの高速検索と、階層構造を活かした効率的なルックアップの両立

2. **イミュータブルなデータ構造による状態管理**

   - 不変（immutable）データ構造を用いた状態管理の徹底
   - `Readonly<T>`型や`Object.freeze()`を活用した意図しない変更の防止
   - 参照の共有によるメモリ効率の向上と、変更検知の明確化

3. **関数型コレクション操作の活用**

   - 命令型ループから`filter`、`map`、`reduce`などの関数型高階関数への移行
   - パイプライン処理による複雑なデータ変換の簡潔な表現
   - チェーン可能なデータ処理による可読性と保守性の向上

4. **ノード検索アルゴリズムの改善**

   - 再帰的な深さ優先検索から、インデックスベースの直接アクセスへの変更
   - ノード ID（ファイルパス・タイプ・名前の組み合わせ）による O(1)検索の実現
   - メモ化（memoization）による繰り返し検索の効率化

5. **ラムダ計算に基づく純粋関数設計**

   - 副作用のない純粋関数による処理の明確化
   - 関数合成（composition）による複雑な処理の構築
   - 引数カリー化（currying）による部分適用と再利用性の向上

6. **データの正規化とセレクタパターン**

   - 正規化されたデータモデルで重複を排除
   - セレクタ関数による効率的なデータアクセス
   - メモ化されたセレクタによる計算コストの削減

実装例として、以下のようなコード改善が考えられます：

```typescript
// テスト結果アクセス効率化のためのインデックス構造
interface TestResultIndex {
  readonly byFilePath: ReadonlyMap<string, Set<string>>;
  readonly byTestName: ReadonlyMap<string, Set<string>>;
  readonly byFullKey: ReadonlyMap<string, TestResultStatus>;
}

// イミュータブルなインデックス更新関数
const updateTestResultIndex = (
  index: TestResultIndex,
  filePath: string,
  testName: string,
  status: TestResultStatus
): TestResultIndex => {
  // 新しいインデックスを作成（既存のを変更しない）
  const newByFilePath = new Map(index.byFilePath);
  const newByTestName = new Map(index.byTestName);
  const newByFullKey = new Map(index.byFullKey);

  // ファイルパスインデックス更新
  const fileTests = newByFilePath.get(filePath) || new Set<string>();
  fileTests.add(testName);
  newByFilePath.set(filePath, fileTests);

  // テスト名インデックス更新
  const testPaths = newByTestName.get(testName) || new Set<string>();
  testPaths.add(filePath);
  newByTestName.set(testName, testPaths);

  // 完全キーインデックス更新
  const fullKey = `${filePath}#${testName}`;
  newByFullKey.set(fullKey, status);

  // 新しいイミュータブルなインデックスを返す
  return {
    byFilePath: newByFilePath,
    byTestName: newByTestName,
    byFullKey: newByFullKey,
  };
};

// メモ化されたファイルステータスチェック
const memoizedCheckFileTestStatus = memoize(
  (
    filePath: string,
    index: TestResultIndex
  ): "success" | "failure" | "unknown" => {
    if (!filePath || !isTestFile(filePath)) {
      return "unknown";
    }

    // ファイルに関連するテスト取得（正規化パスとファイル名の両方を考慮）
    const normalizedPath = path.normalize(filePath);
    const baseNameOnly = path.basename(filePath);

    const fileTests =
      index.byFilePath.get(normalizedPath) ||
      index.byFilePath.get(baseNameOnly) ||
      new Set<string>();

    // 関連テストがない場合
    if (fileTests.size === 0) {
      return "unknown";
    }

    // テストのステータスをチェック（関数型アプローチ）
    const hasFailedTests = Array.from(fileTests).some((testName) => {
      const fullKey = `${normalizedPath}#${testName}`;
      const status = index.byFullKey.get(fullKey);
      return status === TestResultStatus.Failure;
    });

    return hasFailedTests ? "failure" : "success";
  },
  // キャッシュキー生成関数（第2引数）
  (filePath: string) => filePath
);
```

このような最適化により、以下の効果が期待できます：

- テスト結果検索の計算量が O(n)から O(1)に改善
- メモリ使用量の効率化と GC プレッシャーの軽減
- イミュータブルデータによる予測可能な状態管理
- 副作用の局所化による堅牢性と保守性の向上
- 宣言的コードによる可読性と拡張性の向上

データ構造と検索アルゴリズムを最適化することで、特に大規模プロジェクトやテスト数が多い場合のパフォーマンスが大幅に向上します。

## 追加機能実装メモ

### Jest の設定パネルをトップバーのドロップダウンで表示できるように変更 (2024-xx-xx)

- TestSettingsProvider クラスに WebviewPanel を表示するための showWebviewPanel()メソッドを追加
- トップバーに Jest 設定ボタンを配置するための StatusBarItem を追加
  - 表示位置: ステータスバー右側（カバレッジボタンの左）
  - アイコン: $(gear)
  - テキスト: "Jest 設定"
- 新規コマンド「jestTestSelector.showJestSettings」を実装
  - ステータスバーのボタンクリック時に、WebviewPanel で設定画面を表示
  - package.json に新コマンドの設定を追加
  - activationEvents にもイベント登録
- WebviewPanel は、既に表示されている場合は前面に表示し、初回または閉じられた後は新規作成

この変更により、今まではサイドパネルでのみ表示できた設定オプション画面をトップバーのドロップダウンアイコンからも直接開けるようになり、ユーザーの操作性が向上しました。WebviewPanel は画面の広いスペースを使用できるため、多数の設定オプションを見やすく表示できます。
